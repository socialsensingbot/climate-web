Index: amplify/backend/function/query/src/app.ts
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/* tslint:disable:no-console */\nimport * as express from \"express\";\nimport * as bodyParser from \"body-parser\";\nimport {queries} from \"./queries\";\nimport {QueryMetadataSets} from \"./metdata\";\nimport * as NodeCache from \"node-cache\";\nimport {AggregationMap, MapMetadata, RegionGeography, ServiceMetadata} from \"./map-data\";\nimport {TwitterApi} from \"twitter-api-v2\";\nimport {Pool} from \"mysql\";\n\nconst awsServerlessExpressMiddleware = require(\"aws-serverless-express/middleware\");\n\nconst queryCache = new NodeCache({stdTTL: 60 * 60, checkperiod: 60 * 60, useClones: true});\nconst dateFromMillis = (time: number) => {\n    const dateTime = new Date(time);\n    return new Date(dateTime.getFullYear(), dateTime.getMonth(), dateTime.getDate());\n};\nconst stage = process.env.AWS_LAMBDA_FUNCTION_NAME.substring(\"query-\".length);\nconsole.log(\"STAGE: \" + stage);\nconst dev = stage === \"dev\";\n// Load modules\n\nexport const roundToHour = (timestamp: number): any => {\n    const date: Date = new Date(timestamp);\n    date.setUTCMinutes(0);\n    date.setUTCSeconds(0);\n    date.setUTCMilliseconds(0);\n    return date.getTime();\n};\n\nexport const roundToMinute = (timestamp: number): any => {\n    const date: Date = new Date(timestamp);\n    date.setUTCSeconds(0);\n    date.setUTCMilliseconds(0);\n    return date.getTime();\n};\n\nexport const roundTo15Minute = (timestamp: number): any => {\n    const date: Date = new Date(timestamp);\n    date.setUTCMinutes(Math.floor(date.getUTCMinutes() / 15) * 15);\n    date.setUTCSeconds(0);\n    date.setUTCMilliseconds(0);\n    return date.getTime();\n};\n// Only set to disable the entire API, i.e. to protect the dev database from excessively long queries.\nconst disabled = false;\nmodule.exports = (connection: Pool, twitter: TwitterApi) => {\n\n\n    // declare a new express app\n    const app = express();\n    app.use(bodyParser.json());\n    app.use(awsServerlessExpressMiddleware.eventContext());\n\n    app.use((req, res, next) => {\n        // Enable CORS for all methods\n        res.header(\"Access-Control-Allow-Origin\", \"*\");\n        res.header(\"Access-Control-Allow-Headers\", \"*\");\n        res.setHeader(\"X-SocialSensing\", \"true\");\n        next();\n    });\n\n\n    let metadata = null;\n    let queryMap = null;\n\n    const sql = async (options: {\n        sql: string;\n        values?: any;\n    }, tx = false): Promise<any[]> => {\n        return new Promise((resolve, reject) => {\n            connection.getConnection((err, poolConnection) => {\n                if (tx) {\n                    poolConnection.beginTransaction();\n                }\n                poolConnection.query(options, (error, results) => {\n                    if (error) {\n                        console.error(error);\n                        reject(error);\n                    } else {\n                        let s: string = JSON.stringify(results);\n                        console.log(options.sql, options.values, s.substring(0, s.length > 1000 ? 1000 : s.length));\n                        console.log(\"Returned \" + results.length + \" rows\");\n                        resolve(results);\n                        if (tx) {\n                            poolConnection.commit();\n                        }\n                    }\n                    poolConnection.release();\n                });\n            });\n\n        });\n    };\n\n    // Analytics Queries\n\n    app.get(\"/query/:name\", async (req, res) => {\n        return res.status(405).json({error: \"GET is not supported for queries, use POST instead.\"});\n    });\n\n    const cache = (res, key: string, value: () => Promise<any>, options: { duration: number } = {duration: 60}) => {\n        if (disabled) {\n            res.setHeader(\"X-SocialSensing-API-Disabled\");\n            res.status(500);\n            return;\n        }\n        res.setHeader(\"X-SocialSensing-CachedQuery-Key\", key);\n        if (queryCache.has(key)) {\n            console.log(\"Returned from cache \" + key);\n            res.setHeader(\"X-SocialSensing-CachedQuery-Key\", key);\n            res.setHeader(\"X-SocialSensing-CachedQuery-Expires-At\", queryCache.getTtl(key));\n            res.setHeader(\"X-SocialSensing-CachedQuery-Expires-In-Minutes\", (queryCache.getTtl(key) - Date.now()) / (60 * 1000));\n            res.setHeader(\"X-SocialSensing-CachedQuery-Expires-In-Hours\", (queryCache.getTtl(key) - Date.now()) / (60 * 60 * 1000));\n            res.json(queryCache.get(key));\n            return;\n        } else {\n            console.log(\"Retrieving query for \" + key);\n\n            res.setHeader(\"X-SocialSensing-CachedQuery\", \"false\");\n            value().then(result => {\n                queryCache.set(key, result, options.duration);\n                res.json(result);\n            }).catch(e => handleError(res, e));\n        }\n    };\n\n    app.post(\"/query/:name\", async (req, res) => {\n        console.log(\"Query \" + req.params.name, req.body);\n        const key = req.params.name + \":\" + JSON.stringify(req.body);\n        cache(res, key, async () => {\n            if (!queryMap) {\n                queryMap = queries;\n            }\n            console.log(queryMap[req.params.name]);\n            return await sql((queryMap[req.params.name])(req.body));\n        });\n    });\n\n    // General Reference Data Queries\n    app.get(\"/refdata/:name\", (req, res) => {\n        if (!metadata) {\n            metadata = new QueryMetadataSets(connection);\n        }\n        metadata[req.params.name].then(results => res.json(results))\n                                 .catch(error => {\n                                     console.error(error);\n                                     metadata = null;\n                                     return res.json({error: error.message, details: JSON.stringify(error)});\n                                 });\n    });\n\n\n    // Reference Data for UI and Analytics\n    app.get(\"/refdata/:name\", (req, res) => {\n        if (!metadata) {\n            metadata = new QueryMetadataSets(connection);\n        }\n        metadata[req.params.name].then(results => res.json(results))\n                                 .catch(error => {\n                                     metadata = null;\n                                     console.error(error);\n                                     return res.json({error: error.message, details: JSON.stringify(error)});\n                                 });\n    });\n\n\n    // Map Related Queries\n    app.post(\"/map/metadata\", async (req, res) => {\n\n\n        cache(res, req.path, async () => {\n            const data = await sql({\n                                       sql:    `select * from ref_map_metadata`,\n                                       values: {}\n                                   });\n            return {\n                version: \"1.0\",\n                maps:    data,\n                start:   {\n                    lat:  53,\n                    lng:  -2,\n                    zoom: 6\n                }\n\n            } as ServiceMetadata;\n\n        });\n\n\n    });\n\n\n    function handleError<ResBody>(res, e): void {\n        res.status(500).json(\n            {error: JSON.stringify(e), errorMessage: e.message, errorAsString: e.toString(), errorStack: dev ? e.stack : \"n/a\"});\n    }\n\n    async function getMap(mapId: string): Promise<any> {\n        return (await sql({\n                              // language=MySQL\n                              sql: `select *\n                                    from ref_map_metadata\n                                    where id = ?`, values: [mapId]\n                          }))[0];\n    }\n\n    const maps = sql({\n                         // language=MySQL\n                         sql: `select *\n                               from ref_map_metadata`, values: []\n                     }).then(rows => {\n        const allMaps = {};\n        rows.forEach(map => allMaps[map.id] = map);\n        return allMaps;\n    });\n\n\n    app.post(\"/map/:map/metadata\", async (req, res) => {\n        cache(res, req.path, async () => {\n\n\n            const map = await getMap(req.params.map);\n\n            // const hazards = await sql({\n            //                               // language=MySQL\n            //                               sql: `select hazard\n            //                                 from ref_map_metadata_hazards\n            //                                 where map_id = ?`, values: [req.params.map]\n            //                           });\n\n\n            const regionTypes = await sql({\n                                              // language=MySQL\n                                              sql: `select region_id as id, title\n                                                    from ref_map_metadata_region_types\n                                                    where map_id = ?`, values: [req.params.map]\n                                          });\n\n\n            const regionAggregations = (await sql({\n                                                      // language=MySQL\n                                                      sql: `select region_aggregation_type_id as id\n                                                            from ref_map_metadata_region_aggregations\n                                                            where map_id = ?`, values: [req.params.map]\n                                                  })).map(i => i.id);\n\n            console.log(\"map=\", map);\n            return {\n\n                id:       map.id,\n                title:    map.title,\n                version:  map.version,\n                location: map.location,\n                // hazards:           hazards.map(i => i.hazard),\n                regionTypes,\n                regionAggregations,\n                defaultRegionType: map.default_region_type,\n                start:             {\n                    lat:  map.start_lat,\n                    lng:  map.start_lng,\n                    zoom: map.start_zoom\n                }\n            } as MapMetadata;\n\n        });\n\n    });\n\n    const warningsValues = (warning: string) => {\n        if (warning === \"only\") {\n            return [1, 1];\n        }\n        if (warning === \"include\") {\n            return [0, 1];\n        }\n        if (warning === \"exclude\") {\n            return [0, 0];\n        }\n        throw new Error(\"Unrecognized warning option: \" + warning);\n    };\n\n    app.post(\"/map/:map/region-type/:regionType/text-for-regions\", async (req, res) => {\n        const start = Math.floor(req.body.startDate / 1000);\n        const lastDate: Date = (await maps)[req.params.map].last_date;\n        const endDate: number = lastDate == null ? req.body.endDate : Math.min(req.body.endDate, lastDate.getTime());\n        const end = Math.floor(endDate / 1000);\n        const periodLengthInSeconds: number = end - start;\n        console.debug(\"Period Length in Seconds: \" + periodLengthInSeconds);\n        console.debug(\"StartDate: \" + new Date(req.body.startDate));\n        console.debug(\"EndDate: \" + new Date(endDate));\n        console.debug(\"Start: \" + new Date(start * 1000));\n        console.debug(\"End: \" + new Date(end * 1000));\n\n        cache(res, req.path + \":\" + JSON.stringify(req.body), async () => {\n\n            return (await sql({\n                                  // language=MySQL\n                                  sql: `select t.source_json            as json,\n                                               t.source_html            as html,\n                                               r.source_timestamp       as timestamp,\n                                               r.source_id              as id,\n                                               ST_AsGeoJSON(t.location) as location,\n                                               r.region                 as region\n                                        FROM live_text t,\n                                             mat_view_regions r\n                                        WHERE t.source = r.source\n                                          and t.source_id = r.source_id\n                                          and t.hazard = r.hazard\n                                          and r.region_type = ?\n                                          and r.region in (?)\n                                          and r.hazard IN (?)\n                                          and r.source IN (?)\n                                          and r.warning IN (?)\n                                          and floor((? - unix_timestamp(r.source_timestamp)) / ?) = 0\n                                          and not t.deleted\n                                        order by r.source_timestamp desc    `,\n                                  values: [req.params.regionType, req.body.regions, req.body.hazards, req.body.sources,\n                                           warningsValues(req.body.warnings),\n                                           end, periodLengthInSeconds]\n                              })).map(i => {\n                i.json = JSON.parse(i.json);\n                return i;\n            });\n\n\n        }, {duration: 60});\n    });\n\n    app.post(\"/map/:map/region-type/:regionType/geography\", async (req, res) => {\n        cache(res, req.path, async () => {\n\n\n            const geography = await sql({\n                                            // language=MySQL\n                                            sql: `select ST_AsGeoJSON(boundary) as geo, region\n                                                  from ref_geo_regions gr,\n                                                       ref_map_metadata mm\n                                                  where gr.map_location = mm.location\n                                                    and mm.id = ?\n                                                    and region_type = ?`, values: [req.params.map, req.params.regionType]\n                                        });\n            const regionGeoMap: RegionGeography = {};\n            for (const row of geography) {\n                regionGeoMap[row.region] = JSON.parse(row.geo);\n            }\n            return regionGeoMap;\n        }, {duration: 24 * 60 * 60});\n    });\n\n    app.post(\"/map/:map/aggregations\", async (req, res) => {\n\n        cache(res, req.path, async () => {\n\n            const aggregationTypes = await sql({\n                                                   // language=MySQL\n                                                   sql: `select rat.id as region_aggregation_type_id, rat.title as title\n                                                         from ref_map_metadata_region_aggregations rmmra,\n                                                              ref_map_region_aggregation_types rat\n                                                         where rat.id = rmmra.region_aggregation_type_id\n                                                           and rmmra.map_id = ?`, values: [req.params.map]\n                                               });\n\n\n            const aggroMap: AggregationMap = {};\n            for (const aggType of aggregationTypes) {\n                aggroMap[aggType.region_aggregation_type_id] = {aggregates: []};\n\n                const aggregations = await sql({\n                                                   // language=MySQL\n                                                   sql: `select distinct ram.region_aggregation_id as region_aggregation_id,\n                                                                         ra.title                  as title\n                                                         from ref_map_region_aggregation_mappings ram,\n                                                              ref_map_region_aggregations ra\n                                                         where ra.id = ram.region_aggregation_id\n                                                           and ra.region_aggregation_type_id = ?`,\n                                                   values: [aggType.region_aggregation_type_id]\n                                               });\n                for (const agg of aggregations) {\n                    const aggregationMappings = await sql({\n                                                              // language=MySQL\n                                                              sql: `select distinct ram.region      as region,\n                                                                                    ram.region_type as region_type\n                                                                    from ref_map_region_aggregation_mappings ram\n                                                                    where ram.region_aggregation_id = ?`,\n                                                              values: [agg.region_aggregation_id]\n                                                          });\n                    const mappingsMap = {};\n                    for (const aggMapping of aggregationMappings) {\n                        if (!mappingsMap[aggMapping.region_type]) {\n                            mappingsMap[aggMapping.region_type] = [];\n                        }\n                        mappingsMap[aggMapping.region_type].push(aggMapping.region);\n                    }\n\n                    aggroMap[aggType.region_aggregation_type_id].aggregates.push(\n                        {id: agg.region_aggregation_id, title: agg.title, regionTypeMap: mappingsMap});\n                }\n\n            }\n\n\n            return aggroMap;\n        }, {duration: 24 * 60 * 60});\n    });\n\n    app.post(\"/map/:map/region-type/:regionType/recent-text-count\", async (req, res) => {\n        const lastDate: Date = (await maps)[req.params.map].last_date;\n        const endDate: number = lastDate == null ? req.body.endDate : Math.min(req.body.endDate, lastDate.getTime());\n\n        cache(res, req.path + \":\" + JSON.stringify(req.body), async () => {\n            const rows = await sql({\n                                       // language=MySQL\n                                       sql:    `SELECT r.region AS region, count(*) AS count\n                                                FROM mat_view_regions r\n                                                WHERE r.region_type = ?\n                                                  AND r.source_timestamp between ? and ?\n                                                  AND r.hazard IN (?)\n                                                  AND r.source IN (?)\n                                                  AND r.warning IN (?)\n                                                GROUP BY r.region\n                                               `,\n                                       values: [req.params.regionType, new Date(req.body.startDate),\n                                                new Date(endDate), req.body.hazards, req.body.sources,\n                                                warningsValues(req.body.warnings),]\n                                   });\n            const result = {};\n            for (const row of rows) {\n                result[\"\" + row.region] = row.count;\n            }\n            return result;\n\n        }, {duration: 60});\n\n\n    });\n\n\n    app.post(\"/map/:map/now\", async (req, res) => {\n        const lastDate: Date = (await maps)[req.params.map].last_date;\n        const endDate: number = lastDate == null ? Date.now() : lastDate.getTime();\n        res.json(endDate);\n    });\n\n    app.post(\"/map/:map/region-type/:regionType/regions\", async (req, res) => {\n        cache(res, req.path, async () => {\n            const rows = await sql({\n                                       // language=MySQL\n                                       sql: `select region\n                                             from ref_geo_regions gr,\n                                                  ref_map_metadata mm\n                                             where gr.region_type = ?\n                                               and gr.map_location = mm.location\n                                               and mm.id = ?`,\n                                       values: [req.params.regionType, req.params.map]\n                                   });\n            const result = [];\n            for (const row of rows) {\n                result.push(row.region);\n            }\n            return result;\n\n        }, {duration: 24 * 60 * 60});\n    });\n\n\n    async function getCachedStats(end: number, periodLengthInSeconds: number, req): Promise<any[]> {\n        return await sql({\n                             // language=MySQL\n                             sql: `select *\n                                   from cache_stats_calc\n                                   where end_time = ?\n                                     and period_length = ?\n                                     and region_type = ?\n                                     and hazards = ?\n                                     and sources = ?\n                                     and warnings = ?`,\n                             values: [end, periodLengthInSeconds,\n                                      req.params.regionType, req.body.hazards.join(\",\"), req.body.sources.join(\"?\"),\n                                      req.body.warnings,\n                             ]\n                         }, true);\n    }\n\n    app.post(\"/map/:map/region-type/:regionType/stats\", async (req, res) => {\n\n        cache(res, req.path + \":\" + JSON.stringify(req.body), async () => {\n\n            const firstDateInSeconds = (await sql({\n                                                      // language=MySQL\n                                                      sql: `select unix_timestamp(max(source_timestamp)) as ts\n                                                            from mat_view_first_entries\n                                                            where hazard IN (?)\n                                                              and source IN (?)`, values: [req.body.hazards, req.body.sources]\n                                                  }))[0].ts\n            console.debug(\"First date in seconds: \" + firstDateInSeconds);\n            const result = {};\n\n            const lastDate: Date = (await maps)[req.params.map].last_date;\n            const endDate: number = lastDate == null ? req.body.endDate : Math.min(req.body.endDate, lastDate.getTime());\n            const start = Math.floor(req.body.startDate / 1000);\n            const end = Math.ceil(Math.floor(endDate / 1000) / (60 * 60)) * 60 * 60;\n            const periodLengthInSeconds: number = Math.ceil((end - start) / (60 * 60)) * 60 * 60;\n            const maxPeriods: number = (end - firstDateInSeconds) / periodLengthInSeconds;\n\n            console.debug(\"Period Length in Seconds: \" + periodLengthInSeconds);\n            console.debug(\"StartDate: \" + new Date(req.body.startDate));\n            console.debug(\"EndDate: \" + new Date(endDate));\n            console.debug(\"Start: \" + new Date(start * 1000));\n            console.debug(\"End: \" + new Date(end * 1000));\n            let rows = await getCachedStats(end, periodLengthInSeconds, req);\n\n            if (rows.length === 0) {\n                // console.log(\"Test Values: \", testValues);\n                try {\n                    await sql({\n                                  // language=MySQL\n                                  sql: `insert into cache_stats_calc(exceedance, count, region, end_time, period_length, region_type,\n                                                                     hazards,\n                                                                     sources, warnings)\n                                        select (select exceedance\n                                                from (select cume_dist() OVER w * 100.0   as exceedance,\n                                                             rhs.period                   as period,\n                                                             IFNULL(lhs.count, rhs.count) as count\n                                                      from (SELECT count(source_id)                                    as count,\n                                                                   floor((? - unix_timestamp(r.source_timestamp)) / ?) as period\n\n                                                            FROM mat_view_regions r\n                                                            WHERE r.region = regions.region\n                                                              and r.region_type = ?\n                                                              and r.hazard IN (?)\n                                                              and r.source IN (?)\n                                                              and r.warning IN (?)\n                                                              and not r.deleted\n                                                            group by period\n                                                            order by period\n                                                           ) lhs\n                                                               RIGHT OUTER JOIN (select value as period, 0 as count from ref_integers where value < ?) rhs\n                                                                                ON lhs.period = rhs.period\n                                                          WINDOW w AS (ORDER BY IFNULL(lhs.count, rhs.count) desc)) x\n                                                where period = 0\n                                                  and count > 0) as exceedance,\n                                               (SELECT count(*) as count\n                                                FROM mat_view_regions r\n                                                WHERE r.region = regions.region\n                                                  and r.region_type = ?\n                                                  and r.hazard IN (?)\n                                                  and r.source IN (?)\n                                                  and r.warning IN (?)\n                                                  and not r.deleted\n                                                  and r.source_timestamp between ? and ?\n                                               )                 as count,\n                                               regions.region    as region,\n                                               ?                 as end_time,\n                                               ?                 as period_length,\n                                               ?                 as region_type,\n                                               ?                 as hazards,\n                                               ?                 as sources,\n                                               ?                 as warnings\n                                        from (select distinct region_id as region from ref_map_regions where region_type_id = ?) as regions`,\n                                  values: [end, periodLengthInSeconds,\n                                           req.params.regionType, req.body.hazards, req.body.sources,\n                                           warningsValues(req.body.warnings),\n                                           maxPeriods,\n                                           req.params.regionType, req.body.hazards, req.body.sources,\n                                           warningsValues(req.body.warnings),\n                                           new Date(req.body.startDate), new Date(req.body.endDate),\n                                           end, periodLengthInSeconds,\n                                           req.params.regionType, req.body.hazards.join(\",\"), req.body.sources.join(\",\"),\n                                           req.body.warnings, req.params.regionType\n                                  ]\n                              }, true);\n                } catch (e) {\n                    console.warn(e);\n                }\n                // todo: I know this is awful but I can't figure out why the previous INSERT is not immediately available.\n                await sleep(100);\n                rows = await getCachedStats(end, periodLengthInSeconds, req);\n            }\n\n            for (const row of rows) {\n                if (req.body.debug) {\n                    console.info(\"Fetching row \", row);\n                }\n\n                result[\"\" + row.region] = {count: row.count, exceedance: row.exceedance};\n            }\n\n            return result;\n\n        }, {duration: 5 * 60});\n\n    });\n\n    function sleep(ms) {\n        return new Promise((resolve) => {\n            setTimeout(resolve, ms);\n        });\n    }\n\n\n    app.listen(3000, () => {\n        console.log(\"App started\");\n    });\n\n    // Export the app object. When executing the application local this does nothing. However,\n    // to port it to AWS Lambda we will create a wrapper around that will load the app from\n    // this file\n    return app;\n};\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/amplify/backend/function/query/src/app.ts b/amplify/backend/function/query/src/app.ts
--- a/amplify/backend/function/query/src/app.ts	(revision 46b478f4263872542cdb6406bd1f0278df79b46e)
+++ b/amplify/backend/function/query/src/app.ts	(date 1633020366770)
@@ -511,65 +511,71 @@
             let rows = await getCachedStats(end, periodLengthInSeconds, req);
 
             if (rows.length === 0) {
+
+                const regionRows = await sql({
+                                                 sql:    `select distinct region_id as region from ref_map_regions where region_type_id = ?`,
+                                                 values: [req.params.regionType]
+                                             });
+
                 // console.log("Test Values: ", testValues);
                 try {
-                    await sql({
-                                  // language=MySQL
-                                  sql: `insert into cache_stats_calc(exceedance, count, region, end_time, period_length, region_type,
-                                                                     hazards,
-                                                                     sources, warnings)
-                                        select (select exceedance
-                                                from (select cume_dist() OVER w * 100.0   as exceedance,
-                                                             rhs.period                   as period,
-                                                             IFNULL(lhs.count, rhs.count) as count
-                                                      from (SELECT count(source_id)                                    as count,
-                                                                   floor((? - unix_timestamp(r.source_timestamp)) / ?) as period
+                    const regionPromises = {};
+                    for (const row of regionRows) {
+                        const region = row.region;
+                        const regionPromise = await sql({
+                                                            // language=MySQL
+                                                            sql:    `insert into cache_stats_calc(exceedance, count, region, end_time,
+                                                                                                  period_length, region_type,
+                                                                                                  hazards,
+                                                                                                  sources, warnings)
+                                                                     select exceedance,
+                                                                            count,
+                                                                            ? as region,
+                                                                            ? as end_time,
+                                                                            ? as period_length,
+                                                                            ? as region_type,
+                                                                            ? as hazards,
+                                                                            ? as sources,
+                                                                            ? as warnings
+                                                                     from (select cume_dist() OVER w * 100.0   as exceedance,
+                                                                                  rhs.period                   as period,
+                                                                                  IFNULL(lhs.count, rhs.count) as count
+                                                                           from (SELECT count(source_id)                                    as count,
+                                                                                        floor((? - unix_timestamp(r.source_timestamp)) / ?) as period
 
-                                                            FROM mat_view_regions r
-                                                            WHERE r.region = regions.region
-                                                              and r.region_type = ?
-                                                              and r.hazard IN (?)
-                                                              and r.source IN (?)
-                                                              and r.warning IN (?)
-                                                              and not r.deleted
-                                                            group by period
-                                                            order by period
-                                                           ) lhs
-                                                               RIGHT OUTER JOIN (select value as period, 0 as count from ref_integers where value < ?) rhs
-                                                                                ON lhs.period = rhs.period
-                                                          WINDOW w AS (ORDER BY IFNULL(lhs.count, rhs.count) desc)) x
-                                                where period = 0
-                                                  and count > 0) as exceedance,
-                                               (SELECT count(*) as count
-                                                FROM mat_view_regions r
-                                                WHERE r.region = regions.region
-                                                  and r.region_type = ?
-                                                  and r.hazard IN (?)
-                                                  and r.source IN (?)
-                                                  and r.warning IN (?)
-                                                  and not r.deleted
-                                                  and r.source_timestamp between ? and ?
-                                               )                 as count,
-                                               regions.region    as region,
-                                               ?                 as end_time,
-                                               ?                 as period_length,
-                                               ?                 as region_type,
-                                               ?                 as hazards,
-                                               ?                 as sources,
-                                               ?                 as warnings
-                                        from (select distinct region_id as region from ref_map_regions where region_type_id = ?) as regions`,
-                                  values: [end, periodLengthInSeconds,
-                                           req.params.regionType, req.body.hazards, req.body.sources,
-                                           warningsValues(req.body.warnings),
-                                           maxPeriods,
-                                           req.params.regionType, req.body.hazards, req.body.sources,
-                                           warningsValues(req.body.warnings),
-                                           new Date(req.body.startDate), new Date(req.body.endDate),
-                                           end, periodLengthInSeconds,
-                                           req.params.regionType, req.body.hazards.join(","), req.body.sources.join(","),
-                                           req.body.warnings, req.params.regionType
-                                  ]
-                              }, true);
+                                                                                 FROM mat_view_regions r
+                                                                                 WHERE r.region = ?
+                                                                                   and r.region_type = ?
+                                                                                   and r.hazard IN (?)
+                                                                                   and r.source IN (?)
+                                                                                   and r.warning IN (?)
+                                                                                   and not r.deleted
+                                                                                 group by period
+                                                                                 order by period
+                                                                                ) lhs
+                                                                                    RIGHT OUTER JOIN (select value as period, 0 as count from ref_integers where value < ?) rhs
+                                                                                                     ON lhs.period = rhs.period
+                                                                               WINDOW w AS (ORDER BY IFNULL(lhs.count, rhs.count) desc)) x
+                                                                     where period = 0
+                                                                       and count > 0
+                                                                    `,
+                                                            values: [region, end, periodLengthInSeconds, req.params.regionType,
+                                                                     req.body.hazards.join(","),
+                                                                     req.body.sources.join(","),
+                                                                     req.body.warnings, end, periodLengthInSeconds,
+                                                                     region, req.params.regionType, req.body.hazards, req.body.sources,
+                                                                     warningsValues(req.body.warnings),
+                                                                     maxPeriods
+                                                            ]
+                                                        }, true);
+                        regionPromises[region] = regionPromise;
+                    }
+                    for (const region in regionPromises) {
+                        if (regionPromises.hasOwnProperty(region)) {
+                            await regionPromises[region];
+                        }
+                    }
+
                 } catch (e) {
                     console.warn(e);
                 }
Index: amplify/team-provider-info.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>{\n  \"dev\": {\n    \"awscloudformation\": {\n      \"AuthRoleName\": \"amplify-socialsensing-dev-183906-authRole\",\n      \"UnauthRoleArn\": \"arn:aws:iam::686957444051:role/amplify-socialsensing-dev-183906-unauthRole\",\n      \"AuthRoleArn\": \"arn:aws:iam::686957444051:role/amplify-socialsensing-dev-183906-authRole\",\n      \"Region\": \"eu-west-2\",\n      \"DeploymentBucketName\": \"amplify-socialsensing-dev-183906-deployment\",\n      \"UnauthRoleName\": \"amplify-socialsensing-dev-183906-unauthRole\",\n      \"StackName\": \"amplify-socialsensing-dev-183906\",\n      \"StackId\": \"arn:aws:cloudformation:eu-west-2:686957444051:stack/amplify-socialsensing-dev-183906/6da31140-62fe-11ea-a0c9-060e4e394d84\",\n      \"AmplifyAppId\": \"dtmxl3q3i7oix\",\n      \"APIGatewayAuthURL\": \"https://s3.amazonaws.com/amplify-socialsensing-dev-183906-deployment/amplify-cfn-templates/api/APIGatewayAuthStack.json\"\n    },\n    \"categories\": {\n      \"auth\": {\n        \"socialsensingf07a871c\": {},\n        \"userPoolGroups\": {}\n      },\n      \"function\": {\n        \"S3Triggerb3a090e2\": {\n          \"deploymentBucketName\": \"amplify-socialsensing-dev-183906-deployment\",\n          \"s3Key\": \"amplify-builds/S3Triggerb3a090e2-754e48743050344b787a-build.zip\"\n        },\n        \"query\": {\n          \"deploymentBucketName\": \"amplify-socialsensing-dev-183906-deployment\",\n          \"s3Key\": \"amplify-builds/query-774e4f7234496b7a4d6b-build.zip\"\n        },\n        \"mvrefresh\": {\n          \"deploymentBucketName\": \"amplify-socialsensing-dev-183906-deployment\",\n          \"s3Key\": \"amplify-builds/mvrefresh-4a54385966567a474b67-build.zip\"\n        },\n        \"twitterCompliance\": {\n          \"deploymentBucketName\": \"amplify-socialsensing-dev-183906-deployment\",\n          \"s3Key\": \"amplify-builds/twitterCompliance-345744665841366d6969-build.zip\"\n        }\n      },\n      \"hosting\": {\n        \"amplifyhosting\": {\n          \"appId\": \"dtmxl3q3i7oix\",\n          \"type\": \"cicd\"\n        }\n      }\n    }\n  },\n  \"prod\": {\n    \"awscloudformation\": {\n      \"AuthRoleName\": \"amplify-socialsensing-prod-224245-authRole\",\n      \"UnauthRoleArn\": \"arn:aws:iam::686957444051:role/amplify-socialsensing-prod-224245-unauthRole\",\n      \"AuthRoleArn\": \"arn:aws:iam::686957444051:role/amplify-socialsensing-prod-224245-authRole\",\n      \"Region\": \"eu-west-2\",\n      \"DeploymentBucketName\": \"amplify-socialsensing-prod-224245-deployment\",\n      \"UnauthRoleName\": \"amplify-socialsensing-prod-224245-unauthRole\",\n      \"StackName\": \"amplify-socialsensing-prod-224245\",\n      \"StackId\": \"arn:aws:cloudformation:eu-west-2:686957444051:stack/amplify-socialsensing-prod-224245/76208f10-6320-11ea-9f6c-06bdd06f2a66\",\n      \"AmplifyAppId\": \"dtmxl3q3i7oix\"\n    },\n    \"categories\": {\n      \"auth\": {\n        \"socialsensingf07a871c\": {},\n        \"userPoolGroups\": {}\n      },\n      \"function\": {\n        \"S3Triggerb3a090e2\": {\n          \"secretsPathAmplifyAppId\": \"dtmxl3q3i7oix\",\n          \"deploymentBucketName\": \"amplify-socialsensing-prod-224245-deployment\",\n          \"s3Key\": \"amplify-builds/S3Triggerb3a090e2-34614f6e574c74506878-build.zip\"\n        },\n        \"query\": {\n          \"secretsPathAmplifyAppId\": \"dtmxl3q3i7oix\",\n          \"deploymentBucketName\": \"amplify-socialsensing-prod-224245-deployment\",\n          \"s3Key\": \"amplify-builds/query-4577674430744a775253-build.zip\"\n        },\n        \"mvrefresh\": {\n          \"secretsPathAmplifyAppId\": \"dtmxl3q3i7oix\",\n          \"deploymentBucketName\": \"amplify-socialsensing-prod-224245-deployment\",\n          \"s3Key\": \"amplify-builds/mvrefresh-744d53374871686d677a-build.zip\"\n        },\n        \"twitterCompliance\": {\n          \"secretsPathAmplifyAppId\": \"dtmxl3q3i7oix\",\n          \"deploymentBucketName\": \"amplify-socialsensing-prod-224245-deployment\",\n          \"s3Key\": \"amplify-builds/twitterCompliance-5046457044726449472f-build.zip\"\n        }\n      },\n      \"hosting\": {\n        \"amplifyhosting\": {\n          \"type\": \"cicd\"\n        }\n      }\n    }\n  },\n  \"demo\": {\n    \"awscloudformation\": {\n      \"AuthRoleName\": \"amplify-socialsensing-demo-144920-authRole\",\n      \"UnauthRoleArn\": \"arn:aws:iam::686957444051:role/amplify-socialsensing-demo-144920-unauthRole\",\n      \"AuthRoleArn\": \"arn:aws:iam::686957444051:role/amplify-socialsensing-demo-144920-authRole\",\n      \"Region\": \"eu-west-2\",\n      \"DeploymentBucketName\": \"amplify-socialsensing-demo-144920-deployment\",\n      \"UnauthRoleName\": \"amplify-socialsensing-demo-144920-unauthRole\",\n      \"StackName\": \"amplify-socialsensing-demo-144920\",\n      \"StackId\": \"arn:aws:cloudformation:eu-west-2:686957444051:stack/amplify-socialsensing-demo-144920/7eed7060-bf8f-11ea-9f1b-021ebf3a767c\",\n      \"AmplifyAppId\": \"dtmxl3q3i7oix\"\n    },\n    \"categories\": {\n      \"auth\": {\n        \"socialsensingf07a871c\": {},\n        \"userPoolGroups\": {}\n      },\n      \"function\": {\n        \"S3Triggerb3a090e2\": {}\n      },\n      \"hosting\": {\n        \"amplifyhosting\": {\n          \"appId\": \"dtmxl3q3i7oix\",\n          \"type\": \"cicd\"\n        }\n      }\n    }\n  },\n  \"pwsdemo\": {\n    \"awscloudformation\": {\n      \"AuthRoleName\": \"amplify-socialsensing-pwsdemo-155623-authRole\",\n      \"UnauthRoleArn\": \"arn:aws:iam::686957444051:role/amplify-socialsensing-pwsdemo-155623-unauthRole\",\n      \"AuthRoleArn\": \"arn:aws:iam::686957444051:role/amplify-socialsensing-pwsdemo-155623-authRole\",\n      \"Region\": \"eu-west-2\",\n      \"DeploymentBucketName\": \"amplify-socialsensing-pwsdemo-155623-deployment\",\n      \"UnauthRoleName\": \"amplify-socialsensing-pwsdemo-155623-unauthRole\",\n      \"StackName\": \"amplify-socialsensing-pwsdemo-155623\",\n      \"StackId\": \"arn:aws:cloudformation:eu-west-2:686957444051:stack/amplify-socialsensing-pwsdemo-155623/54ff9df0-de6a-11eb-8cee-0618b2a83ab4\",\n      \"AmplifyAppId\": \"dtmxl3q3i7oix\"\n    },\n    \"categories\": {\n      \"auth\": {\n        \"socialsensingf07a871c\": {},\n        \"userPoolGroups\": {}\n      },\n      \"function\": {\n        \"S3Triggerb3a090e2\": {\n          \"deploymentBucketName\": \"amplify-socialsensing-pwsdemo-155623-deployment\",\n          \"s3Key\": \"amplify-builds/S3Triggerb3a090e2-754e48743050344b787a-build.zip\"\n        },\n        \"query\": {\n          \"deploymentBucketName\": \"amplify-socialsensing-pwsdemo-155623-deployment\",\n          \"s3Key\": \"amplify-builds/query-6d786a326e4e74635a70-build.zip\"\n        }\n      },\n      \"hosting\": {\n        \"amplifyhosting\": {\n          \"appId\": \"dtmxl3q3i7oix\",\n          \"type\": \"cicd\"\n        }\n      }\n    }\n  }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/amplify/team-provider-info.json b/amplify/team-provider-info.json
--- a/amplify/team-provider-info.json	(revision 46b478f4263872542cdb6406bd1f0278df79b46e)
+++ b/amplify/team-provider-info.json	(date 1633020396308)
@@ -24,7 +24,7 @@
         },
         "query": {
           "deploymentBucketName": "amplify-socialsensing-dev-183906-deployment",
-          "s3Key": "amplify-builds/query-774e4f7234496b7a4d6b-build.zip"
+          "s3Key": "amplify-builds/query-59766e4a776f68436b47-build.zip"
         },
         "mvrefresh": {
           "deploymentBucketName": "amplify-socialsensing-dev-183906-deployment",
@@ -62,24 +62,12 @@
       },
       "function": {
         "S3Triggerb3a090e2": {
-          "secretsPathAmplifyAppId": "dtmxl3q3i7oix",
           "deploymentBucketName": "amplify-socialsensing-prod-224245-deployment",
-          "s3Key": "amplify-builds/S3Triggerb3a090e2-34614f6e574c74506878-build.zip"
+          "s3Key": "amplify-builds/S3Triggerb3a090e2-754e48743050344b787a-build.zip"
         },
         "query": {
-          "secretsPathAmplifyAppId": "dtmxl3q3i7oix",
-          "deploymentBucketName": "amplify-socialsensing-prod-224245-deployment",
-          "s3Key": "amplify-builds/query-4577674430744a775253-build.zip"
-        },
-        "mvrefresh": {
-          "secretsPathAmplifyAppId": "dtmxl3q3i7oix",
           "deploymentBucketName": "amplify-socialsensing-prod-224245-deployment",
-          "s3Key": "amplify-builds/mvrefresh-744d53374871686d677a-build.zip"
-        },
-        "twitterCompliance": {
-          "secretsPathAmplifyAppId": "dtmxl3q3i7oix",
-          "deploymentBucketName": "amplify-socialsensing-prod-224245-deployment",
-          "s3Key": "amplify-builds/twitterCompliance-5046457044726449472f-build.zip"
+          "s3Key": "amplify-builds/query-5276587138396670516d-build.zip"
         }
       },
       "hosting": {
@@ -117,16 +105,16 @@
       }
     }
   },
-  "pwsdemo": {
+  "test": {
     "awscloudformation": {
-      "AuthRoleName": "amplify-socialsensing-pwsdemo-155623-authRole",
-      "UnauthRoleArn": "arn:aws:iam::686957444051:role/amplify-socialsensing-pwsdemo-155623-unauthRole",
-      "AuthRoleArn": "arn:aws:iam::686957444051:role/amplify-socialsensing-pwsdemo-155623-authRole",
+      "AuthRoleName": "amplify-socialsensing-test-151705-authRole",
+      "UnauthRoleArn": "arn:aws:iam::686957444051:role/amplify-socialsensing-test-151705-unauthRole",
+      "AuthRoleArn": "arn:aws:iam::686957444051:role/amplify-socialsensing-test-151705-authRole",
       "Region": "eu-west-2",
-      "DeploymentBucketName": "amplify-socialsensing-pwsdemo-155623-deployment",
-      "UnauthRoleName": "amplify-socialsensing-pwsdemo-155623-unauthRole",
-      "StackName": "amplify-socialsensing-pwsdemo-155623",
-      "StackId": "arn:aws:cloudformation:eu-west-2:686957444051:stack/amplify-socialsensing-pwsdemo-155623/54ff9df0-de6a-11eb-8cee-0618b2a83ab4",
+      "DeploymentBucketName": "amplify-socialsensing-test-151705-deployment",
+      "UnauthRoleName": "amplify-socialsensing-test-151705-unauthRole",
+      "StackName": "amplify-socialsensing-test-151705",
+      "StackId": "arn:aws:cloudformation:eu-west-2:686957444051:stack/amplify-socialsensing-test-151705/47ba2900-0fe6-11ec-9580-0a2c5646913c",
       "AmplifyAppId": "dtmxl3q3i7oix"
     },
     "categories": {
@@ -136,12 +124,20 @@
       },
       "function": {
         "S3Triggerb3a090e2": {
-          "deploymentBucketName": "amplify-socialsensing-pwsdemo-155623-deployment",
-          "s3Key": "amplify-builds/S3Triggerb3a090e2-754e48743050344b787a-build.zip"
+          "deploymentBucketName": "amplify-socialsensing-test-151705-deployment",
+          "s3Key": "amplify-builds/S3Triggerb3a090e2-34614f6e574c74506878-build.zip"
         },
         "query": {
-          "deploymentBucketName": "amplify-socialsensing-pwsdemo-155623-deployment",
-          "s3Key": "amplify-builds/query-6d786a326e4e74635a70-build.zip"
+          "deploymentBucketName": "amplify-socialsensing-test-151705-deployment",
+          "s3Key": "amplify-builds/query-7931786b445453743349-build.zip"
+        },
+        "mvrefresh": {
+          "deploymentBucketName": "amplify-socialsensing-test-151705-deployment",
+          "s3Key": "amplify-builds/mvrefresh-4a54385966567a474b67-build.zip"
+        },
+        "twitterCompliance": {
+          "deploymentBucketName": "amplify-socialsensing-test-151705-deployment",
+          "s3Key": "amplify-builds/twitterCompliance-5631444c4c744d6d316e-build.zip"
         }
       },
       "hosting": {
