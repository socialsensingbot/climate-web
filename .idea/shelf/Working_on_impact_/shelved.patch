Index: src/environments/environment.ts
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// This file can be replaced during build by using the `fileReplacements` array.\n// `ng build --prod` replaces `environment.ts` with `environment.prod.ts`.\n// The list of file replacements can be found in `angular.json`.\n\nexport const environment = {\n  name:                 \"dev\",\n  version:              \"dev\",\n  demo:                 false,\n  production:           false,\n  hmr:                  false,\n  rollbar:              false,\n  toolbarColor:         \"primary\",\n  // timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,\n  timezone:             \"UTC\",\n  multipleSessions:     true, //Can the user be logged into multiple devices/browsers at once?\n  maxUsers:             -1, // can be -1 (no limit), 0 - no logins, 1 - single user at a time, n - n concurrent users.\n  locale:               \"en-GB\",\n  confirm:              {\n    email:    \"\",\n    password: \"\"\n  },\n  impact: {\n    //The ability to tag tweets with an impact annotation\n    levels: [\n      {title: \"1 – Minimal\", value: \"minimal\"},\n      {title: \"2 – Minor\", value: \"minor\"},\n      {title: \"3 - Significant\", value: \"significant\"},\n      {title: \"4 - Severe\", value: \"severe\"}\n    ]\n  },\n  features:             [\"\"],\n  showErrors:           false,\n  showLoadingMessages:  true,\n  sanitizeForGDPR:      true,\n  defaultDataSet:       \"live\",\n  availableDataSets:    [\"*\"], // A list of datasets that will appear in the toolbar dropdown, or \"*\" for all.\n  cacheProcessedTweets: false,\n  mapTileUrlTemplate:   \"https://api.mapbox.com/styles/v1/mapbox/streets-v11/tiles/{z}/{x}/{y}?access_token=pk.eyJ1IjoicnVkeWFydGh1ciIsImEiOiJjamZrem1ic3owY3k4MnhuYWt2dGxmZmk5In0.ddp6_hNhs_n9MJMrlBwTVg\"\n  // mapTileUrlTemplate:   \"https://api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}.png?access_token=pk.eyJ1IjoicnVkeWFydGh1ciIsImEiOiJjamZrem1ic3owY3k4MnhuYWt2dGxmZmk5In0.ddp6_hNhs_n9MJMrlBwTVg\"\n\n};\n\n/*\n * For easier debugging in development mode, you can import the following file\n * to ignore zone related error stack frames such as `zone.run`, `zoneDelegate.invokeTask`.\n *\n * This import should be commented out in production mode because it will have a negative impact\n * on performance if an error is thrown.\n */\nimport \"zone.js/dist/zone-error\"; // Included with Angular CLI.\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/environments/environment.ts b/src/environments/environment.ts
--- a/src/environments/environment.ts	(revision 3aa1e33408b39b9818b7c4e0471f79f33cd02f9b)
+++ b/src/environments/environment.ts	(date 1611156875489)
@@ -28,7 +28,7 @@
       {title: "4 - Severe", value: "severe"}
     ]
   },
-  features:             [""],
+  features:             ["impact"],
   showErrors:           false,
   showLoadingMessages:  true,
   sanitizeForGDPR:      true,
Index: src/app/app.component.ts
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import {Component, Inject} from \"@angular/core\";\nimport {AuthService} from \"./auth/auth.service\";\nimport {Hub, Logger} from \"@aws-amplify/core\";\nimport {Router} from \"@angular/router\";\nimport {environment} from \"../environments/environment\";\nimport {PreferenceService} from \"./pref/preference.service\";\nimport {NotificationService} from \"./services/notification.service\";\nimport {SessionService} from \"./auth/session.service\";\nimport * as Rollbar from \"rollbar\";\nimport {RollbarService} from \"./error\";\nimport {DataStore} from \"@aws-amplify/datastore\";\nimport Auth from \"@aws-amplify/auth\";\n\n\nconst log = new Logger(\"app\");\n\nfunction getLang() {\n  if (navigator.languages !== undefined) {\n    return navigator.languages[0];\n  } else {\n    return navigator.language;\n  }\n}\n\n@Component({\n             selector:    \"app-root\",\n             templateUrl: \"./app.component.html\",\n             styleUrls:   [\"./app.component.scss\"]\n           })\nexport class AppComponent {\n\n  title = \"SocialSensing.com\";\n  public isDev: boolean = !environment.production;\n  user: any;\n  isAuthenticated: boolean;\n  public isSignup: boolean = !environment.production;\n  private dataStoreListener: any;\n  private initiateLogout: boolean;\n  private dataStoreSynced: boolean;\n\n  constructor(public auth: AuthService,\n              public pref: PreferenceService,\n              private _router: Router, private _pref: PreferenceService,\n              private _notify: NotificationService,\n              private _session: SessionService,\n              @Inject(RollbarService) private _rollbar: Rollbar) {\n\n    Auth.currentAuthenticatedUser({bypassCache: true})\n        .then(user => this.isAuthenticated = (user != null))\n        .then(user => this.auth.loggedIn = (user != null))\n        .then(() => this.checkSession())\n        .catch(err => log.debug(err));\n    auth.state.subscribe((event: string) => {\n      if (event === AuthService.SIGN_IN) {\n        this.isAuthenticated = true;\n        this.isSignup = false;\n        this.checkSession();\n      }\n      if (event === AuthService.SIGN_OUT) {\n        this.user = undefined;\n        this.isAuthenticated = false;\n        this.isSignup = !environment.production;\n        this._pref.clear();\n      }\n    });\n\n    this._router.events.subscribe((val) => log.verbose(\"Router Event: \", val));\n\n  }\n\n  async checkSession() {\n    log.debug(\"checkSession()\");\n    if (!this.isAuthenticated) {\n      log.debug(\"Not authenticated\");\n      return;\n    }\n    log.debug(\"Authenticated\");\n\n\n    this.dataStoreListener = Hub.listen(\"datastore\", async (capsule) => {\n      const {\n        payload: {event, data},\n      } = capsule;\n\n      console.log(\"DataStore event\", event, data);\n\n      if (event === \"outboxStatus\") {\n        this.dataStoreSynced = data.isEmpty;\n        if (data.isEmpty && this.initiateLogout) {\n          this._notify.show(\"Data synced.\", \"OK\", 2);\n\n          setTimeout(() => this.doLogout(), 500);\n        }\n\n      }\n      if (event === \"ready\" && !this.initiateLogout) {\n        this._notify.show(\"Synced data with the server ...\", \"OK\", 5);\n\n        const user = await Auth.currentAuthenticatedUser();\n        const userInfo = await Auth.currentUserInfo();\n        if (userInfo) {\n          try {\n            await this._pref.init(userInfo);\n          } catch (e) {\n            this._rollbar.error(e);\n            log.error(e);\n            this._notify.show(\n              // tslint:disable-next-line:max-line-length\n              \"There was a problem with your application preferences, please ask an administrator to fix this. The application may not work correctly until you do.\",\n              \"I Will\",\n              30);\n            return;\n          }\n          try {\n            await this._session.open(userInfo);\n          } catch (e) {\n            console.error(\n              \"There was a problem with creating your session, please ask an administrator to look into this.\",\n              e);\n            console.error(user);\n            this._rollbar.error(\n              \"There was a problem with creating your session, please ask an administrator to look into this.\", e);\n          }\n          log.info(\"Locale detected: \" + getLang());\n          log.info(\"Locale in use: \" + this._pref.combined.locale);\n          log.info(\"Timezone detected: \" + Intl.DateTimeFormat().resolvedOptions().timeZone);\n          log.info(\"Timezone in use: \" + this._pref.combined.timezone);\n          // Start the DataStore, this kicks-off the sync process.\n          this._rollbar.configure(\n            {\n              enabled: environment.rollbar,\n              // environment: environment.name,\n              captureIp:    \"anonymize\",\n              code_version: environment.version,\n              payload:      {\n                person: {\n                  id:       userInfo.username,\n                  username: userInfo.username,\n                  groups:   this._pref.groups\n                },\n                // environment: environment.name,\n                environment_info: environment,\n                prefs:            {\n                  group: this._pref.combined\n                }\n              }\n            }\n          );\n\n\n          if (userInfo && userInfo.attributes.profile) {\n\n            this.user = userInfo;\n            this.isAuthenticated = true;\n            this.isSignup = false;\n          }\n        }\n      }\n    });\n    await DataStore.start();\n    this._notify.show(\"Syncing data with the server ...\", \"OK\", 30);\n  }\n\n  public async logout() {\n    await this._session.close();\n    if (!this.dataStoreSynced) {\n      this.initiateLogout = true;\n\n      this._notify.show(\"Syncing data before logout.\", \"OK\", 30);\n    } else {\n      await this.doLogout();\n    }\n\n\n  }\n\n  private async doLogout() {\n    this.isAuthenticated = false;\n    log.info(\"Clearing data store.\");\n    await DataStore.clear();\n    log.info(\"Performing sign out.\");\n    await Auth.signOut()\n              .then(i => this._router.navigate([\"/\"], {queryParamsHandling: \"merge\"}))\n              .catch(err => log.error(err));\n    log.info(\"Performed sign out.\");\n    this.initiateLogout = false;\n  }\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/app/app.component.ts b/src/app/app.component.ts
--- a/src/app/app.component.ts	(revision 3aa1e33408b39b9818b7c4e0471f79f33cd02f9b)
+++ b/src/app/app.component.ts	(date 1611157122191)
@@ -87,7 +87,7 @@
       if (event === "outboxStatus") {
         this.dataStoreSynced = data.isEmpty;
         if (data.isEmpty && this.initiateLogout) {
-          this._notify.show("Data synced.", "OK", 2);
+          this._notify.show("Synced", "OK", 1);
 
           setTimeout(() => this.doLogout(), 500);
         }
@@ -165,8 +165,9 @@
     await this._session.close();
     if (!this.dataStoreSynced) {
       this.initiateLogout = true;
-
-      this._notify.show("Syncing data before logout.", "OK", 30);
+      // failsafe
+      setTimeout(() => this.doLogout(), 5000);
+      this._notify.show("Syncing data before logout.", "OK", 5);
     } else {
       await this.doLogout();
     }
@@ -175,6 +176,9 @@
   }
 
   private async doLogout() {
+    if (!this.initiateLogout) {
+      return;
+    }
     this.isAuthenticated = false;
     log.info("Clearing data store.");
     await DataStore.clear();
Index: src/app/map/twitter/tweet-list/tweet-list.component.ts
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import {Component, EventEmitter, Input, NgZone, OnDestroy, OnInit, Output} from \"@angular/core\";\nimport {Tweet} from \"../tweet\";\nimport {PreferenceService} from \"../../../pref/preference.service\";\nimport {Hub, Logger} from \"@aws-amplify/core\";\nimport * as $ from \"jquery\";\nimport {IInfiniteScrollEvent} from \"ngx-infinite-scroll\";\nimport {Subscription, timer} from \"rxjs\";\nimport {environment} from \"../../../../environments/environment\";\nimport {AnnotationService} from \"../../../pref/annotation.service\";\n\nconst log = new Logger(\"tweet-list\");\nlet loadTweets = false;\n\nsetInterval(() => {\n  // todo: the use of setTimeout is very brittle, revisit.\n  if ((window as any).twttr && (window as any).twttr.widgets) {\n    (window as any).twttr.widgets.load($(\"app-tweet-list\")[0]);\n  }\n\n}, 1000);\n\nlet twitterBound = false;\n\nfunction twitterInit() {\n  if ((window as any).twttr && (window as any).twttr.events) {\n    (window as any).twttr.events.bind(\n      \"rendered\",\n      (event) => {\n        log.debug(event);\n        twitterBound = true;\n        loadTweets = false;\n        $(event.target).parents(\".app-tweet-page\").addClass(\"app-tweet-page-loaded\");\n        Hub.dispatch(\"twitter-panel\", {message: \"render\", event: \"render\", data: event.target});\n        const parent = $(event.target).parent();\n        const atr = $(event.target).parents(\".app-tweet-row\");\n\n        const blockquote = atr.find(\"blockquote\");\n        blockquote.addClass(\"tweet-rendered\");\n        window.setTimeout(() => {\n          atr.addClass(\"app-tweet-row-animate-in\");\n          atr.removeClass(\"app-tweet-row-animate-out\");\n          setTimeout(() => {\n            atr.addClass(\"app-tweet-row-rendered\");\n            atr.removeClass(\"app-tweet-row-animate-in\");\n            if (atr[0]) {\n              localStorage.setItem(\"tweet:\" + atr.attr(\"data-tweet-id\"),\n                                   JSON.stringify(\n                                     {timestamp: Date.now(), html: atr.find(\".app-tweet-item-text\").html()}));\n            }\n          }, 800);\n          if (atr.find(\"blockquote.twitter-tweet-error\").length > 0) {\n            const error = atr.find(\"blockquote.twitter-tweet-error\");\n            error.find(\".app-tweet-item-menu\").hide();\n\n\n            error.css(\"opacity\", 1.0)\n                 .css(\"min-width\", \"516px\")\n                 .css(\"display\", \"block\")\n                 .css(\"text-align\", \"center\");\n            error.parent().addClass(\"app-tweet-item-card\");\n\n            error.text(\"Tweet no longer available\");\n            blockquote.removeClass(\"tweet-rendered\");\n          }\n          try {\n            if (atr.length > 0) {\n              atr.find(\"mat-spinner\").css(\"opacity\", 0);\n              atr.find(\".app-tweet-item-menu\").css(\"opacity\", 1.0);\n              // atr.find(\".tweet-loading-placeholder\").remove();\n            }\n          } catch (e) {\n            log.debug(e);\n          }\n        }, 10);\n\n      }\n    );\n  } else {\n    setTimeout(() => twitterInit(), 500);\n  }\n}\n\ntwitterInit();\n\n\nclass TweetPage {\n  public loaded = false;\n\n  constructor(public page: number, public start: number, public tweets: Tweet[]) {}\n\n  public is(other: TweetPage) {\n    return other.page === this.page\n      && other.start === this.start\n      && this.tweets.length === other.tweets.length\n      && this.tweets.every((tweet, i) => this.tweets[i].id === other.tweets[i].id);\n  }\n}\n\n/**\n * The TweetListComponent is responsible for managing an invisibly\n * paged infinite scroll collection of tweets. At present all\n * tweets are stored in memory but their rendering is scrolled for browser performance.\n */\n@Component({\n             selector:    \"app-tweet-list\",\n             templateUrl: \"./tweet-list.component.html\",\n             styleUrls:   [\"./tweet-list.component.scss\"]\n           })\nexport class TweetListComponent implements OnInit, OnDestroy {\n\n\n  public loaded: boolean[] = [];\n  public tweetCount = 0;\n  public ready: boolean;\n  public scrollDistance = 4;\n  public scrollUpDistance = 4;\n  public throttle = 300;\n  public direction: string;\n  public minPage = 0;\n  public moreToShow: boolean;\n  public pages: TweetPage[] = [];\n  /**\n   * If the set of tweets have been updated (by an ignore/unignore for example) this will emit an event to the parent component.\n   */\n  @Output() public update: EventEmitter<Tweet> = new EventEmitter();\n  /**\n   * A name for this group of tweets presently only \"hidden\" or \"visible\" is allowed.\n   */\n  @Input() public group: \"hidden\" | \"visible\";\n  public firstVisibleDate: Date;\n  // Infinite Scroll End\n  public showDateHeader: boolean;\n  public utc: boolean = environment.timezone === \"UTC\";\n  public cache: any = {};\n  private _destroyed = false;\n  // Infinite scroll start: https://github.com/socialsensingbot/frontend/issues/10\n  private readonly PAGE_SIZE = 5;\n  private readonly INITIAL_PAGES = 3;\n  public maxPage = this.INITIAL_PAGES - 1;\n  private lastDateShow: number;\n  private _dateHeaderTimer: Subscription;\n\n  constructor(private _zone: NgZone, public pref: PreferenceService, public annotate: AnnotationService) {}\n\n  private _tweets: Tweet[] | null = [];\n\n  public get tweets(): Tweet[] {\n    return this._tweets;\n  }\n\n  /**\n   * The tweets to render or null if not yet ready.\n   *\n   * @param val the tweets or null\n   */\n  @Input()\n  public set tweets(val: Tweet[] | null) {\n    if (val === null) {\n      // this.ready = false;\n      this._tweets = [];\n      this.ready = false;\n      this.tweetCount = 0;\n      log.debug(\"Tweets reset\");\n      return;\n    }\n    this.updateTweets(val);\n\n  }\n\n  public show($event: any) {\n    log.debug($event);\n  }\n\n  public sender(tweet) {\n    return tweet.sender;\n  }\n\n  public isPlaceholder(tweet) {\n    return !tweet.valid;\n  }\n\n  public async ignoreSender(tweet, $event: MouseEvent) {\n    await this.pref.groupIgnoreSender(tweet);\n    this.update.emit(tweet);\n  }\n\n  public async unIgnoreSender(tweet, $event: MouseEvent) {\n    await this.pref.groupUnIgnoreSender(tweet);\n    this.update.emit(tweet);\n  }\n\n  public async ignoreTweet(tweet, $event: MouseEvent) {\n    await this.pref.groupIgnoreTweet(tweet);\n    this.update.emit(tweet);\n  }\n\n  public async unIgnoreTweet(tweet, $event: MouseEvent) {\n    await this.pref.groupUnIgnoreTweet(tweet);\n    this.update.emit(tweet);\n  }\n\n  public async annotateTweet(tweet, annotations, $event: MouseEvent) {\n    await this.annotate.addAnnotations(tweet, annotations);\n    this.update.emit(tweet);\n  }\n\n  public async removeTweetAnnotations(tweet, $event: MouseEvent) {\n    await this.annotate.removeAllAnnotations(tweet);\n    this.update.emit(tweet);\n  }\n\n  ngOnInit(): void {\n    this._dateHeaderTimer = timer(1000, 1000).subscribe(() => {\n      if (Date.now() - this.lastDateShow > 1 * 1000) {\n        this.showDateHeader = false;\n      }\n    });\n  }\n\n  public ngOnDestroy(): void {\n    this._destroyed = true;\n    this._dateHeaderTimer.unsubscribe();\n  }\n\n  public isNewDate(i: number) {\n    return i > 0 && this.tweets.length > i && this.tweets[i - 1].day !== this.tweets[i].day;\n  }\n\n  onScrollDown(ev) {\n    log.debug(\"scrolled down!!\", ev);\n    // add items\n    this.direction = \"down\";\n    const oldMax = this.maxPage;\n    if (this.maxPage < this.pages.length - 1) {\n      this.moreToShow = true;\n      this.maxPage += 1;\n    } else {\n      this.moreToShow = false;\n      this.maxPage = this.pages.length - 1;\n    }\n    if (this.minPage <= this.pages.length - this.INITIAL_PAGES) {\n      this.minPage += 1;\n    } else {\n      this.minPage = Math.max(this.pages.length - this.INITIAL_PAGES, 0);\n    }\n    log.debug(this.maxPage);\n    if (oldMax !== this.maxPage) {\n      this.loadPagesOfTweets();\n    }\n    log.debug(\"New max page \" + this.maxPage);\n    log.debug(\"New min page \" + this.minPage);\n  }\n\n  onUp($event: IInfiniteScrollEvent) {\n    log.debug(\"scrolled up!\", $event);\n\n    this.direction = \"up\";\n    const oldMin = this.minPage;\n    if ($event.currentScrollPosition === 0) {\n      this.maxPage = this.INITIAL_PAGES - 1;\n      this.minPage = 0;\n    }\n    if (this.maxPage >= this.INITIAL_PAGES) {\n      this.maxPage -= 1;\n\n    }\n    if (this.minPage > 0) {\n      this.minPage -= 1;\n    }\n    if (oldMin !== this.minPage) {\n      this.loadPagesOfTweets();\n    }\n    log.debug(\"New max page \" + this.maxPage);\n    log.debug(\"New min page \" + this.minPage);\n\n    // if (this.maxTweets > 100) {\n    //   this.maxTweets -= this.PAGE_SIZE;\n    // }\n  }\n\n  public calcFirstVisibleDate() {\n    const checkInView = (elem, partial) => {\n      const container = $(\".app-tweet-list\");\n      const contHeight = container.height();\n      const contTop = container.scrollTop();\n      const contBottom = contTop + contHeight;\n\n      const elemTop = $(elem).offset().top - container.offset().top;\n      const elemBottom = elemTop + $(elem).height();\n\n      const isTotal = (elemTop >= 0 && elemBottom <= contHeight);\n      const isPart = ((elemTop < 0 && elemBottom > 0) || (elemTop > 0 && elemTop <= container.height())) && partial;\n\n      return isTotal || isPart;\n    };\n\n    let firstEl;\n\n    for (const el of $(\".app-tweet-row\")) {\n      if (checkInView(el, true)) {\n        firstEl = $(el);\n        break;\n      }\n    }\n    if (firstEl) {\n      const i = +firstEl.attr(\"data-index\");\n      this.firstVisibleDate = this.tweets[i].date;\n      this.showDateHeader = true;\n      this.lastDateShow = Date.now();\n    }\n  }\n\n  public isCached(id: string) {\n    if (!localStorage.getItem(\"tweet:\" + id)) {\n      return false;\n\n    }\n    const item = JSON.parse(localStorage.getItem(\"tweet:\" + id));\n\n    if (item && item.timestamp > Date.now() - 60 * 50 * 1000) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  public cached(id: string) {\n    log.debug(\"From cache \" + id);\n    return JSON.parse(localStorage.getItem(\"tweet:\" + id)).html;\n  }\n\n  /**\n   * Update the tweets stored in this list.\n   * @param val an array of {@link Tweet}s\n   */\n  private updateTweets(val: Tweet[]) {\n    this.tweetCount = val.length;\n    log.debug(\"updateTweets()\");\n    if (this._destroyed) {\n      return;\n    }\n    let changed = false;\n    if (val.length !== this._tweets.length) {\n      changed = true;\n    } else {\n      for (let i = 0; i < val.length; i++) {\n        if (this._tweets[i].id !== val[i].id) {\n          changed = true;\n        }\n\n      }\n    }\n    if (!changed) {\n      log.debug(\"No change, returning from updateTweets()\");\n      this.ready = true;\n      return;\n    }\n\n    if (this.pages.length !== Math.ceil(val.length / this.PAGE_SIZE)) {\n      this.pages.length = Math.ceil(val.length / this.PAGE_SIZE);\n    }\n    if (val.length !== this._tweets.length) {\n      this._tweets.length = val.length;\n    }\n    if (this.loaded.length !== val.length) {\n      this.loaded.length = val.length;\n    }\n    let currPage = new TweetPage(0, 0, []);\n    this.pages.length = Math.ceil(val.length / this.PAGE_SIZE);\n    for (let i = 0; i < val.length; i++) {\n      const page = Math.floor(i / this.PAGE_SIZE);\n      const tweetOnPage = i % this.PAGE_SIZE;\n      if (this.isCached(val[i].id)) {\n        this.cache[val[i].id] = this.cached(val[i].id);\n      }\n      if (tweetOnPage === 0) {\n        currPage = new TweetPage(page, i, []);\n      }\n      const tweet = val[i];\n      if (tweetOnPage >= currPage.tweets.length) {\n        currPage.tweets.push(tweet);\n      } else {\n        currPage.tweets[tweetOnPage] = tweet;\n      }\n\n      const lastEntryOnPage = i === (val.length - 1) || ((i + 1) % this.PAGE_SIZE) === 0;\n      if (lastEntryOnPage) {\n        // Do not change/reload unchanged pages.\n        if (typeof this.pages[page] === \"undefined\" || !this.pages[page].is(currPage)) {\n          log.debug(`Pages are different for page ${page}: `, this.pages[page], currPage);\n          this.pages[page] = currPage;\n        }\n      }\n\n      this._tweets[i] = tweet;\n      if (this._tweets[i] && this._tweets[i].id !== tweet.id) {\n        this._tweets[i] = tweet;\n      }\n    }\n\n\n    log.debug(this.tweets);\n    this.loadPagesOfTweets();\n    this.moreToShow = this.maxPage < this.pages.length;\n    this.ready = true;\n\n  }\n\n  private loadPagesOfTweets() {\n    for (let i = 0; i <= this.maxPage; i++) {\n      this.animateTweetAppearance(i);\n    }\n  }\n\n  private async animateTweetAppearance(page: number) {\n    if (this.pages[page] && !this.pages[page].loaded) {\n      log.debug(\"Loading tweets by page \" + page);\n      loadTweets = true;\n      this.pages[page].loaded = true;\n    }\n  }\n\n  public async annotationsFor(tweet: Tweet) {\n    return await this.annotate.getAnnotations(tweet);\n  }\n  public async annotationValueFor(tweet: Tweet, key: string) {\n    return (await this.annotate.getAnnotations(tweet))[key];\n  }\n  public async annotationValueIs(tweet: Tweet, key: string, value) {\n    return (await this.annotate.getAnnotations(tweet))[key] === value;\n  }\n  public async annotationValueIsNot(tweet: Tweet, key: string, value) {\n    return !this.annotationValueIs(tweet,key,value);\n  }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/app/map/twitter/tweet-list/tweet-list.component.ts b/src/app/map/twitter/tweet-list/tweet-list.component.ts
--- a/src/app/map/twitter/tweet-list/tweet-list.component.ts	(revision 3aa1e33408b39b9818b7c4e0471f79f33cd02f9b)
+++ b/src/app/map/twitter/tweet-list/tweet-list.component.ts	(date 1611157788125)
@@ -139,6 +139,7 @@
   public maxPage = this.INITIAL_PAGES - 1;
   private lastDateShow: number;
   private _dateHeaderTimer: Subscription;
+  private annotations: any[string][];
 
   constructor(private _zone: NgZone, public pref: PreferenceService, public annotate: AnnotationService) {}
 
@@ -329,6 +330,22 @@
     return JSON.parse(localStorage.getItem("tweet:" + id)).html;
   }
 
+  public async annotationsFor(tweet: Tweet) {
+    return this.annotations[tweet.id];
+  }
+
+  public async annotationValueFor(tweet: Tweet, key: string) {
+    return (await this.annotationsFor(tweet))[key];
+  }
+
+  public async annotationValueIs(tweet: Tweet, key: string, value) {
+    return (await this.annotationValueFor(tweet, key)) === value;
+  }
+
+  public async annotationValueIsNot(tweet: Tweet, key: string, value) {
+    return !this.annotationValueIs(tweet, key, value);
+  }
+
   /**
    * Update the tweets stored in this list.
    * @param val an array of {@link Tweet}s
@@ -419,17 +436,4 @@
       this.pages[page].loaded = true;
     }
   }
-
-  public async annotationsFor(tweet: Tweet) {
-    return await this.annotate.getAnnotations(tweet);
-  }
-  public async annotationValueFor(tweet: Tweet, key: string) {
-    return (await this.annotate.getAnnotations(tweet))[key];
-  }
-  public async annotationValueIs(tweet: Tweet, key: string, value) {
-    return (await this.annotate.getAnnotations(tweet))[key] === value;
-  }
-  public async annotationValueIsNot(tweet: Tweet, key: string, value) {
-    return !this.annotationValueIs(tweet,key,value);
-  }
 }
Index: src/app/pref/annotation.service.ts
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import {EventEmitter, Injectable} from \"@angular/core\";\nimport {Logger} from \"@aws-amplify/core\";\nimport {NotificationService} from \"../services/notification.service\";\nimport {Tweet} from \"../map/twitter/tweet\";\nimport {DataStore, OpType} from \"@aws-amplify/datastore\";\nimport {GroupTweetAnnotations} from \"../../models\";\nimport Auth from \"@aws-amplify/auth\";\n\nconst log = new Logger(\"annotation-service\");\n\n@Injectable({\n              providedIn: \"root\"\n            })\nexport class AnnotationService {\n\n  public tweetAnnotated = new EventEmitter<GroupTweetAnnotations>();\n  public tweetAnnotationsRemoved = new EventEmitter<GroupTweetAnnotations>();\n  private _ready: boolean;\n  private _readyPromise: Promise<boolean> = new Promise<boolean>((resolve) => {\n    const loop = () => {\n      if (this._ready) {\n        resolve(true);\n      } else {\n        log.verbose(\"Waiting for ready.\");\n        setTimeout(loop, 100);\n      }\n    };\n    setTimeout(loop, 50);\n  });\n  private _email: string;\n  private _userInfo: any;\n\n  constructor(private _notify: NotificationService) {\n  }\n\n  private _groups: string[] = [];\n\n  public get groups(): string[] {\n    return this._groups;\n  }\n\n  public async init(userInfo: any) {\n    this._userInfo = userInfo;\n    const groups = (await Auth.currentAuthenticatedUser()).signInUserSession.accessToken.payload[\"cognito:groups\"];\n    if (typeof userInfo.attributes !== \"undefined\") {\n      this._email = userInfo.attributes.email;\n    } else {\n      log.error(\"No attributes in \", userInfo);\n    }\n    if (!groups || groups.length === 1) {\n      this._groups = groups;\n    } else {\n      log.error(\"User is a member of more than one group (not supported)\");\n    }\n    log.debug(\"** Annotation Service Initializing **\");\n    log.debug(userInfo);\n\n    if (!groups || groups.length === 0) {\n      this._notify.show(\n        // tslint:disable-next-line:max-line-length\n        \"Your account is not a member of a group, please ask an administrator to fix this. The application will not work correctly until you do.\",\n        \"I Will\",\n        180);\n      this._groups = [\"__invalid__\"];\n    }\n\n    DataStore.observe(GroupTweetAnnotations).subscribe(msg => {\n      if (msg.opType === OpType.DELETE) {\n        this.tweetAnnotationsRemoved.emit(msg.element);\n      } else {\n        this.tweetAnnotated.emit(msg.element);\n      }\n    });\n\n\n  }\n\n\n  public async waitUntilReady() {\n    return this._readyPromise;\n  }\n\n  public async getAnnotations(tweet: Tweet) {\n    if (!tweet.valid) {\n      throw new Error(\"Shouldn't be trying to retrieve annotations an unparseable tweet.\");\n      return;\n    }\n    try {\n      const result = await DataStore.query(GroupTweetAnnotations, q => q.tweetId(\"eq\", tweet.id));\n      log.debug(result);\n      if (result.length === 0) {\n        return {};\n      } else {\n        return result[0];\n      }\n    } catch (e) {\n      log.error(e);\n      this._notify.show(\"Failed to get annotations for Tweet, this could be a network error. Refresh the page and try\" +\n                          \" again, if this persists please contact support.\", \"OK\", 60);\n    }\n\n  }\n\n\n  public async addAnnotations(tweet: Tweet, annotations: any) {\n    if (!tweet.valid) {\n      throw new Error(\"Shouldn't be trying to annotate an unparseable tweet.\");\n      return;\n    }\n    try {\n\n      const result = await DataStore.query(GroupTweetAnnotations, q => q.tweetId(\"eq\", tweet.id));\n      log.debug(result);\n      if (result.length === 0) {\n        return await DataStore.save(new GroupTweetAnnotations(\n          {\n            url:         tweet.url,\n            tweetId:     tweet.id,\n            annotatedBy: this._email,\n            ownerGroups: this._groups,\n            annotations: JSON.stringify(annotations)\n          }\n        ));\n\n      } else {\n        const mergedAnnotations = JSON.stringify({...JSON.parse(result[0].annotations), ...annotations});\n        return await DataStore.save(GroupTweetAnnotations.copyOf(result[0], m => {\n          m.annotations = mergedAnnotations;\n          m.annotatedBy = this._email;\n        }));\n      }\n    } catch (e) {\n      log.error(e);\n      this._notify.show(\"Failed to annotate Tweet, this could be a network error. Refresh the page and try\" +\n                          \" again, if this persists please contact support.\", \"OK\", 60);\n    }\n\n  }\n\n\n  public async removeAllAnnotations(tweet) {\n    if (!tweet.valid) {\n      throw new Error(\"Shouldn't be trying to remove annotations from an unparseable tweet.\");\n      return;\n    }\n    try {\n      return await DataStore.delete(GroupTweetAnnotations, q => q.tweetId(\"eq\", tweet.id));\n    } catch (e) {\n      log.error(e);\n      this._notify.show(\"Failed to remove annotations for Tweet, this could be a network error. Refresh the page and\" +\n                          \" try\" +\n                          \" again, if this persists please contact support.\", \"OK\", 60);\n    }\n  }\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/app/pref/annotation.service.ts b/src/app/pref/annotation.service.ts
--- a/src/app/pref/annotation.service.ts	(revision 3aa1e33408b39b9818b7c4e0471f79f33cd02f9b)
+++ b/src/app/pref/annotation.service.ts	(date 1611158074857)
@@ -72,7 +72,7 @@
       }
     });
 
-
+    this._ready= true;
   }
 
 
